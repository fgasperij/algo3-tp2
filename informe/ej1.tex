\section{Problema 1: Plan de vuelo}

\subsection{Presentación del problema}

Se quiere crear un sitio web para reservas de pasajes de avi\'on. El sitio debe tener un sistema de b\'usqueda de itinerarios de vuelo. Un itinerario de vuelo, es una sucesi\'on de vuelos los cuales logran llevarte hacia un destino. Dado una ciudad de salida, y una ciudad de llegada, se busca crear un itinirario de vuelos que me lleve desde la ciudad de salida hasta la de llegada.

Dentro de este itinerario, cada vuelo tiene un horario de despegue y uno de aterrizaje. 

Para poder ser un itinerario valido, la ciudad de destino de un vuelo, tiene que ser la ciudad de llegada del pr\'oximo o directamente el destino donde queriamos llegar, y en particular cada vez que llego a una ciudad debo esperar al menos dos horas desde el aterrizaje, para poder tomarme un vuelo, lo cual resulta l\'ogico dado que una persona puede necesitar al menos ese tiempo para tr\'amites de aeropuerto.

Es por eso que se nos pide el mejor itinerario, teniendo al menos dos horas entre cada vuelo, donde mejor itinerario es el que primero llega a la ciudad destino.

Adem\'as se nos pide que la resoluci\'on de este problema se implemente en un complejidad no peor a O($N^{2}$) donde N es la cantidad de vuelos totales que existen en todo el sistema (formen parte del itinerario o no).

\newpage
\subsubsection{Formalmente}


Sea Ciudad un renombre de String.

Sea Vuelo una tupla $<$despegue:Nat, aterrizaje:Nat, origen:Ciudad, destino:Ciudad$>$

Dado $vuelos$:Conj(Vuelo):

Llamemos a $ciudadades$:Conj(Ciudad) al conjunto tal que:

($\forall$ $c$:Ciudad, $c$ $\in$ $ciudades$)  $\Leftrightarrow$ ($\exists$ $v,v'$:Vuelo$/$ $v$,$v'$) $\subset$ $vuelos$ $\wedge$ ($v$.origen $\equiv$ $c$ $\vee$ $v'$.destino $\equiv$ $c$))

Dadas $a,b$:Ciudad, $a,b \in ciudades$. 

Sean los enunciados:

esItinerarioValido(Sec$<$Vuelo$>$ $S$, Ciudad a, Ciudad b) $\equiv$
 
($S_{0}$.origen $\equiv a \wedge S_{S.tamanio-1}$.destino$ \equiv b) \wedge$ 

($\forall$ $i$:Nat, 0 $\leq$ i $<S.tamanio-1$)($S_{i}$.destino $\equiv$ $S_{i+1}$.origen 

$\wedge$ $S_{i}$.aterrizaje + 2 $\leq$ $S_{i+1}$.despegue))

---------------------

Sec$<$Vuelo$>$ s $\subseteq$ Conj(Vuelo) c $\equiv$ 

($\forall i:$Nat, 0 $\leq i \geq$ s )($s_{i}$ $\in $ c) 
 
---------------------------------------------------------------------------------------------

Se nos pide encontrar $S$:Sec$<$Vuelo$>$ tal que 

esItinerarioValido($S$,a,b) $\wedge$ ($S \subseteq$ vuelos) $\wedge$ 

$(\forall$ $S'$:Sec$<$Vuelo$>$ $/$ (esItinerarioValido($S'$,a,b)) $\wedge$ ($S' \subseteq$ vuelos) $\implies$  

$S_{S.tamanio-1}$.aterrizaje$) \leq S'_{S'.tamanio-1}$.aterrizaje))

Se nos pide encontrar $S$:Sec$<$Vuelo$>$ tal que 

esItinerarioValido($S$,a,b) $\wedge$ ($S \subseteq$ vuelos) $\wedge$ 

$(\forall$ $S'$:Sec$<$Vuelo$>$ $/$ (esItinerarioValido($S'$,a,b)) $\wedge$ ($S' \subseteq$ vuelos) $\implies$  

$S_{S.tamanio-1}$.aterrizaje$) \leq S'_{S'.tamanio-1}$.aterrizaje))


\newpage
\subsection{Resolución}

Habiendo caracterizado la soluci\'on a nuestro problema en leguaje formal, vamos a tratar de encontrar una implementaci\'on para un algoritmo que devuelva una instancia de esa soluci\'on.

Dados C:Conj(Vuelo), $inicio$:Ciudad, $destino$:Ciudad y el instante T:Nat, que va a ser un instante de tiempo.

Sea la funci\'on:

boolean ExisteVuelo(Conj(Vuelo) vuelos, Ciudad inicio,Ciudad destino,Nat T) $\equiv$

(inicio $==$ destino) $\vee$ ($\exists$ v:Vuelo, v $\in$ vuelos) $/$ (v.inicio $==$ inicio $\wedge$ v.despegue - 2 $\geq$ T 

$\wedge$ ExisteVuelo(vuelos,v.destino, destino, v.aterrizaje))) 

Esta expresi\'on nos indica si dado un instante T, en alguna ciudad c existe una secuencia de vuelos valida que nos lleva desde c hasta la ciudad destino que queremos llegar.

Solo nos va a interesar un vuelo v tal que exista un itinerario valido hasta tomarnos v y que exista un itinerario valido hasta nuestra ciudad destino a partir de tomarnos v.

Dados C:Conj(Vuelo), $inicio$:Ciudad, $destino$:Ciudad.

Podemos definir el conjunto Validos(C,inicio,destino):Conj(Vuelo), como:

($\forall$ v:Vuelo, v $\in$ Validos(C,inicio,destino)) $\Leftrightarrow$ ((v.origen $==$ $inicio$ $\vee$ ($\exists$ v':Vuelo, v' $\in$ Validos(C,inicio,destino) $/$ v'.destino $==$ v.origen $\wedge$ v'.aterrizaje + 2 $\leq$ v.despegue)) $\wedge$ ExisteVuelo(C,v.destino,$destino$,v.aterrizaje) $\wedge$ v $\in$ C)

Dado este conjunto podemos definir el VueloMinimo:Vuelo, tal que VueloMinimo pertenezca al conjunto de vuelos validos y VueloMinimo sea el primero que aterrice en nuestra ciudad final.

Dados C:Conj(Vuelo), $inicio$:Ciudad, $destino$:Ciudad.

VueloMinimo(C,$inicio$,$destino$) $\equiv$ v:Vuelo $\Leftrightarrow$ (v $\in$ Validos(C,inicio,destino) $\wedge$ v.destino $==$ $destino$ $\wedge$ ($\forall$ v':Vuelo, v' $\in$ Validos(C,inicio,destino) $\wedge$ v'.destino $==$ $destino$) $\implies$ v.aterrizaje $\leq$ v'.aterrizaje)

Nuestro algoritmo va a obtener este VueloMinimo. Las caracteristica de VueloMinimo es que es el primero de los vuelos que llegan a nuestro $destino$ por un itinerario valido.

Asi que, cualquier itinerario valido que contenga a $destino$ en su ultimo vuelo va a ser soluci\'on de nuestro problema.

Para ello solo deberiamos elegir vuelos que me lleven a mi ciudad inicial, utilizando como ultimo vuelo a VueloMinimo. En particular vamos a obtener siempre el primer vuelo que llegue a la ciudad desde donde sale mi actual VueloMinimo y pertenezcan al conjunto de vuelos posibles.

Para obtener el conjunto de vuelos v\'alidos vamos a implementar una funci\'on recursiva que itere por los vuelos que salen desde la ciudad inicial hasta la ciudad final, los siguientes enunciados son importantes para entender en que se basa el algoritmo.

Dados, $vuelos$:conj(Vuelo), una ciudad $C$, $inicio$:Ciudad y $destino$:Ciudad

Corolario 1:

\begin{align*}
(ExisteVuelo(vuelos,inicio, C, 0) \wedge (\exists v:Vuelo, v \in Validos(vuelos,inicio,C))\\
(v.destino == C \wedge ExisteVuelo(vuelos,C, destino, v.aterrizaje))) \implies \\ ExisteVuelo(vuelos,inicio, destino, 0)
\end{align*}
Corolario 2:

\begin{align*}
(\forall C':Ciudad / \exists v:Vuelo, v.inicio == C' \wedge v.destino == C)\\
(ExisteVuelo(vuelos,C,destino,v.aterrizaje) \implies \\
ExisteVuelo(vuelos,C',destino,v.despegue) \wedge v \in Validos(vuelos,C',destino)
\end{align*}
\begin{align*}
\end{align*}


Corolario 3:

Sea v:Vuelo tal que:
\begin{align*}
v.destino == C \wedge v \in Validos(vuelos,C,destino) \wedge\\
(\forall v':Vuelo, v' \in Validos(vuelos,C,destino)(v.aterrizaje \geq v'.aterrizaje))\\
\end{align*}
Entonces:
\begin{align*}
(\forall C':Ciudad / \exists w:Vuelo, w.inicio == C' \wedge w.destino == C)\\
w.aterizaje + 2 \leq v.despegue \implies w \in Validos(vuelos,C',destino) 
\end{align*}





\subsection{PseudoC\'odigo a la c++}

\newpage
Nuestro algoritmo final quedaria de la siguiente manera:

Definimos Color como un enum $[$BLANCO,ROJO,VERDE$]$

Definimos un Aeropuerto como un tupla $\langle$ ciudad$:$Ciudad,vuelosQueSalen$:
$Conj(Vuelo),

vuelosQueLlegan$:$Conj(Vuelo),id$:$Nat $\rangle$ 


\begin{algorithm}[H]
\begin{algorithmic}[1]
\STATE Aeropuerto[] aeropuertos = construirArrayDeAeropuertos(vuelos,inicio,final)
\STATE Sec$\langle$Vuelo$\rangle$ $itinerario$ $=$ $[]$

$/*$ Esta sesgada la funcion con T $=$ -2 ya que vamos a preguntar si existeVuelo a partir de T $=$ 0.
En la posicion 0 se encuentra el aeropuerto de la ciudad inicial, y en la posici\'on 1, el de la ciudad final $*/$
\IF{(existeVuelo(aeropuertos, aeropuertos[0],aeropuertos[1],-2))}
	\STATE Vuelo min = vueloMinimo(aeropuerto$[1]$.vuelosQueLlegan())
\STATE $itinerario$.agregar(min,0)
\WHILE {(min.inicio != inicio) }
	\STATE Vuelo min $=$ vueloMinimo(min.inicio.vuelosQueLlegan())
	\STATE $itinerario$.agregar(min,0)
\ENDWHILE
\ENDIF
\RETURN $itinerario$
\caption{Sec$\langle$Vuelo$\rangle$ itinerario(Conj(Vuelo) vuelos, Ciudad inicio, Ciudad final)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\STATE Conj(Ciudad) ciudades = null
\STATE ciudades.agregar(inicio)
\STATE ciudades.agregar(final)
\FOR {(Vuelo vuelo: Vuelos)}	
	\STATE ciudades.agregar(vuelo.origen)
	\STATE ciudades.agregar(vuelo.destino)
\ENDFOR
\STATE Aeropuerto[] aeropuertos = new Aeropuerto[ciudades.size];
\STATE Mapa$\langle$Ciudad, Nat$\rangle$ ids $=$ $\emptyset$
\STATE ids.agregar(inicio,0)
\STATE ids.agregar(final,1)
\STATE aeropuertos[0] = new Aeropuerto (inicio,$\emptyset$,$\emptyset$,0)
\STATE aeropuertos[1] = new Aeropuerto (final,$\emptyset$,$\emptyset$,1)
\STATE ciudades.remover(inicio)
\STATE ciudades.remover(final)
\STATE Nat i = 2
\FOR {(Ciudad ciudad: ciudades)}	
	\STATE aeropuertos[i] = new Aeropuerto (ciudad,$\emptyset$,$\emptyset$,i)
	\STATE ids.agregar(ciudad,i++)
\ENDFOR
\STATE i $=$ 1
\FOR {(Vuelo vuelo: Vuelos)}	
	\STATE vuelo.id = i	
	\STATE vuelo.color = BLANCO	
	\STATE int id = ids.obtener(vuelo.origen)
	\STATE ciudades.obtener(id).vuelosQueSalen().agregar(vuelo)
	\STATE int id = ids.obtener(vuelo.destino)
	\STATE ciudades.obtener(id).vuelosQueLlegan().agregar(vuelo)
\ENDFOR
\RETURN ciudades
\caption{Aeropuerto[] construirArrayDeAeropuertos(Conj(Vuelo) vuelos, Ciudad inicio, Ciudad final)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}
Esta funcion va a asignarle un id a cada una de las ciudades y luego construir un array donde en la posicion i, se encuentra la ciudad con id $=$ 1.

Implementada sobre un trie o sobre un hashmap, para el diccionario de ids me daria una complejidad al algoritmo de crear el mapa de aeropuertos cercana a O(n) en n numero de vuelos. Los nombres de la ciudad tienden a ser Strings de bajo costo de procesamiento en un trie, y en un hashmap la cantidad total de ciudades con aeropuertos en el mundo, es un numero relativamente bajo, por lo tanto se podr\'ia implementar de forma eficiente.
Nuestra implementaci\'on usa un treeset, asi que la complejidad de crear nuestros aeropuertos es O(n.log(n))

\begin{algorithm}[H]
\begin{algorithmic}[1]
\IF {(inicio $==$ destino)}	
		\RETURN TRUE
\ENDIF
\IF {(t + 2 $\leq$ inicio.ultimoVueloQueLlega())}	
		\RETURN TRUE
\ENDIF
\STATE boolean llego $=$ false;
\STATE Conj(vuelo) vuelos $=$ inicio$.$vuelosQueSalen;
\STATE inicio$.$vuelosQueSalen $=$ $\emptyset$;
\FOR{(Vuelo v $:$ vuelos)}	    
    \IF {(v.despegue $\geq$ t+2)}	
        \IF{(v.color $==$ BLANCO)}     				        	
        		\IF {(existeVuelo(aeropuertos,v.destino,final,v.aterrizaje)}
				\STATE llego = true
				\STATE v.color = VERDE
				\IF {(inicio.ultimoVueloQuellega $<$ v.llegada)}	
					\STATE inicio.ultimoVueloQuellega = v.llegada
				\ENDIF
			\ELSE
				\STATE v.color = ROJO								
	    		\ENDIF    			
		\ENDIF
	\ELSE
		\STATE incio.vuelosQuellegan.agregar(v)										    
    \ENDIF
\ENDFOR
\RETURN $llego$
\caption{boolean existeVuelo(Aeropuerto[] aeropuertos, Aeropuerto inicio, Aeropuerto final, int t)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}

Esta funcion tambien me va a colorear de verde los vuelos que encuentre que lleguen a destino.

El conjunto de vuelos que estan contenidos en un itinerario valido son los que marco de verde.

La funci\'on es recursiva, para poder cumplir la complejidad requerida creamos un puntero a la lista de vuelos de un aeropuerto, y despues vaciamos esa lista, para que dado que entro en una recursion de un vuelo, no volver a consultar por los mismos vuelos de una ciudad. Esto se basa en el principio de que si dentro de una recursi\'on visito la misma ciudad, el T de la primera recursi\'on va a ser menor al de la segunda, por lo tanto los vuelos que me pueda tomar en la segunda, ya voy a haberlos evaluado en la primera.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\STATE Vuelo min = null
\FOR{(Vuelo v: vuelos)}
	\STATE min $=$ (min$==$null $\vee$ v.aterrizaje $\leq$ min.aterrizaje) $\wedge$ v.color $==$ VERDE
\ENDFOR
\RETURN min
\caption{Vuelo vueloMinimo(Conj(Vuelo) vuelos)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}

Esta funcion la implementamos como un puntero al primer vuelo verde que llega a la ciudad, para que la complejidad de buscar el vuelo minimo sea O(1), igualmente implementada de esta manera no afectaria a la complejidad final que seria O($N^{2}$).

//A PARTIR DE ACA NO SE QUE VOY A PONER Y QUE NO


Primero notamos que para encontrar el mejor itinerario de movimientos de un turista, yendo de ciudad a ciudad en aviones, iba a ser necesario recorrer los vuelos que sean posibles desde la ciudad donde estabamos parados y ver a que otros vuelos nos llevaban. 

Notamos que dado un instante T, el flujo de vuelos que pod\'iamos tomarnos desde una ciudad dependia siempre de la ciudad inicial, y del momento en el que nos encontremos en esa ciudad, y nos iba a interesar solo los que finalizaran en la ciudad final con menor instante de aterrizaje.

Luego para que nuestra soluc\'on tuviera el menor instante T de aterrizaje en $destino$, vamos a definir al m\'inimo vuelo posible en nuestra ciudad final tal que:

m\'inimoFinal $\equiv$ v $\Leftrightarrow$ 


Por lo tanto se podria visualizar el flujo de aviones de ciudad en ciudad como una grafo direccional donde los vertices son las ciudades, y existen aristas por cada uno de los vuelos. 

Sin ninguna restricci\'on a partir de esto, no podr\'iamos introducir el concepto de horario de vuelo.
Estas aristas no ibamos a poder recorrerlas de cualquier forma, ya que un vuelo solo puedo tomarmelo en determinados horarios de arribo a una ciudad. 

Por lo tanto ibamos a necesitar recorrerlas asociadas a un T:Nat que seria el tiempo desde que salimos desde el origen hasta llegar a la ciudad actual.

Viendo esta estructura podriamos recorrer con un BFS modificado, los caminos que lleven de a hasta b, agregandole una variable temporal a ese BFS, para el descubrimiento de aristas realizarlo solo si el vuelo asociado despegaba despu\'es del instante T de llegada.

A ese T, que seria el tiempo de entrada a una ciudad habria que agregarle 2hs, que son las que se necesitan para los tr\'amites un usuario del itinerario. Tambi\'en notamos que podriamos simplemente cargar el despegue de los vuelos como 2 hs antes ya que llegar a una ciudad y esperar 2 hs para el despegue, es lo mismo que decir que el despegue es 2 horas antes.

Con esta estructura y con un BFS modificado para considerar un tiempo T, podr\'iamos hallar todos los caminos que vayan desde a hasta b. 

El problema que notamos es que esta funci\'on a priori, era bastante ineficiente. ya que si llegabamos a una ciudad dos veces con el mismo instante t, debiamos calcular dos veces si un camino de vuelos nos llebaba a una soluci\'on o no.

Para optimizar este mecanimos, optamos por marcar cuando sean posibles y cuando no llega a la ciudad final dado que nos tomamos un cierto vuelo. Para marcarlo utilzamos, un flag de coloreo para aristas.

Con este coloreo no solo logramos que nuestro algoritmo recorra exactamente una vez cada arista, sino que no reorra aristas que nunca se puede tomar.

Tomamos la idea de coloreo del recorrido de un BFS, del libro Introduction to algorithm, donde lo usa para marcar nodos totalmente descubiertos, nodos parcialmente descubiertos y nodos sin descubrir.

En nuestra implementaci\'on vamos a colorear aristas, ya que lo que queremos marcar son los vuelos que nos lleven desde a hasta b.

Luego simplemente podemos ir al nodo que le corresponde a la ciudad b, tomarnos el vuelo que tenga aterrizaje m\'inimo, es decir el que primero llegue a la ciudad final b y recorrer cualquier camino marcado como posible hasta a.

Notamos entonces que para todo vuelo v, yo puedo definir una subsoluci\'on optima dado un instante T tal que me diga el mejor camino de vuelos a partir de tomarme v.
Por lo tanto, nuestra solucion seria el mejor camino de vuelos que yo puedo tomarme a partir de tomarme cualquier vuelo que salga de la ciudad inicial con T = 0, con esa idea creamos la siguiente funcion recursiva.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\FOR {(Vuelo v: m.obtener(inicio).vuelosDeSalida) }
	\IF {(v.destino $==$ destino)}	
		\STATE return TRUE
	\ENDIF
    \IF {(v.despegue $\geq$ t)}	
        \RETURN existeVuelo(m,v.destino,final,v.aterrizaje)
    \ENDIF
\ENDFOR
\RETURN $FALSE$
\caption{boolean existeVuelo(Mapa$<$Ciudad,Vuelo$>$) m, Ciudad inicio, Ciudad final, int t)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}

Donde m es el mapa de $<$Ciudad,Conj(Vuelo)$>$ tal que dada un conjunto c de vuelos, las claves de m son las Ciudades(c) y en el valor de cada clave, obtengo los vuelos que salen y llegan de esa ciudad. Luego veremos que costruir este mapa nos va a agregar un costo a la complejidad final del algoritmo.  

Lo que consigo con este algoritmo es un boolean que me indica si llego a la ciudad final desde una ciudad inicial con un tiempo asociado. Entonces lo que nos interesaria saber a nosotros es si existeVuelo(m,a,b,0) $\equiv$ TRUE. 

Como vemos podemos relacionar este algoritmo con la t\'ecnica recursiva de BFS.

Como vemos esta funci\'on recursiva tiene un costo alto de complejidad ya que si por ejemplo llegamos desde dos caminos distintos a la misma ciudad y luego tomamos el mismo vuelo para salir de ella, no sabriamos a priori que ese camino ya se calculo en la primera iteraci\'on. He aqu\'i que agregamos el concepto de Colores a los caminos.

Vamos a marcar a todos los vuelos en color Blanco al principio del algoritmo, para poder identificar los vuelos que todavia no nos pudimos tomar.

Vamos a marcar de color verde los vuelos a los que por algun camino llegamos a la ciudad destino, por un camino de vuelos o en su defecto llegamos a un camino verde.

Y finalmente vamos a marcar de color rojo a todo vuelo v que dado que nos lo tomamos no llegamos a ning\'un camino verde ni al destino.

Para ello vamos a modificar levemente el algoritmo anterior de recorrido de nuestro sistema. Recordemos, los vuelos inician en color BLANCO.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\IF {(v.destino $==$ destino)}	
		\RETURN TRUE
\ENDIF
\STATE boolean llego = false;
\FOR {(Vuelo v: m.obtener(inicio).vuelosDeSalida) }	    
    \IF {(v.despegue $\geq$ t)}	
		\IF{(v.color $==$ VERDE)}
			\STATE llego = TRUE
        \ENDIF
        \IF{(v.color $==$ BLANCO)}     				        	
        		\IF {(existeVuelo(m,v.destino,final,v.aterrizaje)}
				\STATE llego = true;
				\STATE v.color = VERDE;
			\ELSE
				\STATE v.color = ROJO;								
	    		\ENDIF    			
		\ENDIF		    
    \ENDIF
\ENDFOR
\RETURN $llego$
\caption{boolean existeVuelo(Mapa$<$Ciudad,Vuelo$>$) m, Ciudad inicio, Ciudad final, int t)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}

Con este algoritmo cuando terminemos de recorrer el sistema de vuelos, vamos a tener que agarrar el camino Verde, que nos lleve al primer vuelo que aterrice en la ciudad final y este marcado del mismo color.

Para eso lo que haremos ser\'a obtener recursivamente las ciudades desde nuestra ciudad final, tomandome exactamente el primer vuelo que aterrice y sea de color verde.

Ahora nuestra variable T, va a ser el horario de despegue de cada vuelo que haya tomado. 

Es decir, si el primer vuelo que llega a mi ciudad final (o sea el de menor horario de aterrizaje) y tenga color verde tiene un horario de despegue a las 14hs y sale de la ciudad $c$, entonces voy a buscar los vuelos que esten marcados de verde y lleguen a c en horario menor o igual a 14hs. Recordemos aca entra en juego, lo de alargar el horario de aterrizaje 2 horas para cada vuelo.
Como mi vuelo pertenecia a un camino verde, existe al menos un vuelo que sale de $c$ y aterriza antes de las 14hs.

Luego la sucesi\'on de vuelos obtenida de esta manera desde la ciudad final, comenzando con T = $\infty$ es una soluci\'on a nuestro problema ya que va desde a hasta b, y el \'ultimo vuelo de esa sucesi\'on es el de menor horario de aterrizaje en b, de los vuelos que llegan desde a hasta b por un camino verde.

\subsection{Demostración}
\newpage

\subsection{Análisis de complejidad}
Nuestra implementaci\'on consta de dos partes:

1. Construir el array de aeropuertos.

2. Encontrar el conjunto de vuelos validos desde la ciudad origen hasta la destino.

Para construir el array de aeropuertos, lo que se hace es contar la cantidad de ciudades para crear un array de ese tamaño.
Para ello, se carga cada ciudad en un TreeSet. Como la cantidad de ciudades la podemos acotar por la cantidad de vuelos, ya que a lo sumo tenemos 2 ciudades por vuelo, sea N la cantidad de vuelos, la cantidad de ciudades maximas es de 2.N, por lo tanto el costo de crear este Set es a lo sumo O(n.Log(n))

Crear el array tiene una complejidad temporal de O(N) a lo sumo y espacial de 2.N.

Luego se le asocia un id a estas ciudades, que va a ser la posicion donde se van a encontrar en el array. Para poder asociarle este id se construye un mapa $\langle Ciudad,ID \rangle$.
Buscar en este mapa nos va a costar O(Log(N)).

Luego se asocio cada vuelo a la posicion donde se encuentran la ciudad destino e inicio de ese vuelo.
Para ello se busca el id en el mapa. Entonces para asociar todos los vuelos tenemos la complejidad es de O(n.Log(n)).

Luego la complejidad final de construir el array es O(n.Log(n)).

Sea i cualquier instancia de recursion de el algoritmo.

Se puede asegurar que los vuelos de la ciudad inicio en i, no van a estar incluidos en cualquier recursion a partir de i. Es decir, no existen ciclos en la recursion, donde un ciclo seria volver a recursar sobre un vuelo que sea de una iteracion anterior.

Por lo tanto para cualquier recursion a partir de i, se chequean a lo sumo todos los vuelos exactamente una vez.

Cuando se genera una llamada recursiva se colorea el vuelo, por lo tanto ese vuelo nunca mas va a ser llamada recursivamente ya que se conoce el estado para cualquer instante de tiempo.

Por lo tanto el algoritmo puedo tener tantas llamadas recursivas como vuelos distintos tenga.
El numero de vuelos distintos es N.

Y para cada llamada recursiva a lo sumo puedo iterar por todos los vuelos de una ciudad, los cuales estan acotados por N.

Por lo tanto la cantidad total de vuelos que se iteran dado que se llego a una ciudad, en un instante T esta acotado por la cantida total de llamadas recursivas y la cantidad de vuelos que a lo sumo se iteran en cada una. Por lo tanto la cantidad de iteraciones que se realizan tiene una complejidad menor a O($N^{2})$.





\subsection{Tests de complejidad}
