\section{Problema 1: Plan de vuelo}

\subsection{Presentación del problema}

Se quiere crear un sitio web para reservas de pasajes de avi\'on. El sitio debe tener un sistema de b\'usqueda de itinerarios de vuelo. Un itinerario de vuelo, es una sucesi\'on de vuelos los cuales logran llevarte hacia un destino. Dado una ciudad de salida, y una ciudad de llegada, se busca crear un itinirario de vuelos que me lleve desde la ciudad de salida hasta la de llegada.

Dentro de este itinerario, cada vuelo tiene un horario de despegue y uno de aterrizaje. 

Para poder ser un itinerario valido, la ciudad de destino de un vuelo, tiene que ser la ciudad de llegada del pr\'oximo o directamente el destino donde queriamos llegar, y en particular cada vez que llego a una ciudad debo esperar al menos dos horas desde el aterrizaje, para poder tomarme un vuelo, lo cual resulta l\'ogico dado que una persona puede necesitar al menos ese tiempo para tr\'amites de aeropuerto.

Es por eso que se nos pide el mejor itinerario, teniendo al menos dos horas entre cada vuelo, donde mejor itinerario es el que primero llega a la ciudad destino.

Adem\'as se nos pide que la resoluci\'on de este problema se implemente en un complejidad no peor a O($N^{2}$) donde N es la cantidad de vuelos totales que existen en todo el sistema (formen parte del itinerario o no).

\newpage
\subsubsection{Formalmente}


Sea Ciudad un renombre de String.

Sea Vuelo una tupla $<$despegue:Nat, aterrizaje:Nat, origen:Ciudad, destino:Ciudad$>$

Dado $vuelos$:Conj(Vuelo):

Llamemos a $ciudadades$:Conj(Ciudad) al conjunto tal que:

($\forall$ $c$:Ciudad, $c$ $\in$ $ciudades$)  $\Leftrightarrow$ ($\exists$ $v,v'$:Vuelo$/$ $v$,$v'$) $\subset$ $vuelos$ $\wedge$ ($v$.origen $\equiv$ $c$ $\vee$ $v'$.destino $\equiv$ $c$))

Dadas $a,b$:Ciudad, $a,b \in ciudades$. 

Sean los enunciados:

esItinerarioValido(Sec$<$Vuelo$>$ $S$, Ciudad a, Ciudad b) $\equiv$
 
($S_{0}$.origen $\equiv a \wedge S_{S.tamanio-1}$.destino$ \equiv b) \wedge$ 

($\forall$ $i$:Nat, 0 $\leq$ i $<S.tamanio-1$)($S_{i}$.destino $\equiv$ $S_{i+1}$.origen 

$\wedge$ $S_{i}$.aterrizaje + 2 $\leq$ $S_{i+1}$.despegue))

---------------------

Sec$<$Vuelo$>$ s $\subseteq$ Conj(Vuelo) c $\equiv$ 

($\forall i:$Nat, 0 $\leq i \geq$ s )($s_{i}$ $\in $ c) 
 
---------------------------------------------------------------------------------------------

Se nos pide encontrar $S$:Sec$<$Vuelo$>$ tal que 

esItinerarioValido($S$,a,b) $\wedge$ ($S \subseteq$ vuelos) $\wedge$ 

$(\forall$ $S'$:Sec$<$Vuelo$>$ $/$ (esItinerarioValido($S'$,a,b)) $\wedge$ ($S' \subseteq$ vuelos) $\implies$  

$S_{S.tamanio-1}$.aterrizaje$) \leq S'_{S'.tamanio-1}$.aterrizaje))

Se nos pide encontrar $S$:Sec$<$Vuelo$>$ tal que 

esItinerarioValido($S$,a,b) $\wedge$ ($S \subseteq$ vuelos) $\wedge$ 

$(\forall$ $S'$:Sec$<$Vuelo$>$ $/$ (esItinerarioValido($S'$,a,b)) $\wedge$ ($S' \subseteq$ vuelos) $\implies$  

$S_{S.tamanio-1}$.aterrizaje$) \leq S'_{S'.tamanio-1}$.aterrizaje))


\newpage
\subsection{Resolución}

Habiendo caracterizado la soluci\'on a nuestro problema en leguaje formal, vamos a tratar de encontrar una implementaci\'on para un algoritmo que devuelva una instancia de esa soluci\'on.

Dados C:Conj(Vuelo), $inicio$:Ciudad, $destino$:Ciudad y el instante T:Nat, que va a ser un instante de tiempo.

Sea la funci\'on:

boolean ExisteVuelo(Conj(Vuelo) vuelos, Ciudad inicio,Ciudad destino,Nat T) $\equiv$

(inicio $==$ destino) $\vee$ ($\exists$ v:Vuelo, v $\in$ vuelos) $/$ (v.inicio $==$ inicio $\wedge$ v.despegue - 2 $\geq$ T 

$\wedge$ ExisteVuelo(vuelos,v.destino, destino, v.aterrizaje))) 

Esta expresi\'on nos indica si dado un instante T, en alguna ciudad c existe una secuencia de vuelos valida que nos lleva desde c hasta la ciudad destino que queremos llegar.

Solo nos va a interesar un vuelo v tal que exista un itinerario valido hasta tomarnos v y que exista un itinerario valido hasta nuestra ciudad destino a partir de tomarnos v.

Dados C:Conj(Vuelo), $inicio$:Ciudad, $destino$:Ciudad.

Podemos definir el conjunto Validos(C):Conj(Vuelo), como:

($\forall$ v:Vuelo, v $\in$ Validos(C)) $\Leftrightarrow$ ((v.origen $==$ $inicio$ $\vee$ ($\exists$ v':Vuelo, v' $\in$ Validos(C) $/$ v'.destino $==$ v.origen $\wedge$ v'.aterrizaje + 2 $\leq$ v.despegue)) $\wedge$ ExisteVuelo(C,v.destino,$destino$,v.aterrizaje) $\wedge$ v $\in$ C)

Dado este conjunto podemos definir el VueloMinimo:Vuelo, tal que VueloMinimo pertenezca al conjunto de vuelos validos y VueloMinimo sea el primero que aterrice en nuestra ciudad final.

Dados C:Conj(Vuelo), $inicio$:Ciudad, $destino$:Ciudad.

VueloMinimo(C,$inicio$,$destino$) $\equiv$ v:Vuelo $\Leftrightarrow$ (v $\in$ Validos(C) $\wedge$ v.destino $==$ $destino$ $\wedge$ ($\forall$ v':Vuelo, v' $\in$ Validos(C) $\wedge$ v'.destino $==$ $destino$) $\implies$ v.aterrizaje $\leq$ v'.aterrizaje)

Nuestro algoritmo va a obtener este VueloMinimo. Las caracteristica de VueloMinimo es que es el primero de los vuelos que llegan a nuestro $destino$ por un itinerario valido.

Asi que, cualquier itinerario valido que contenga a $destino$ en su ultimo vuelo va a ser soluci\'on de nuestro problema.

Para ello solo deberiamos elegir vuelos que me lleven a mi ciudad inicial, utilizando como ultimo vuelo a VueloMinimo. En particular vamos a obtener siempre el primer vuelo que llegue a la ciudad desde donde sale mi actual VueloMinimo y sean pertenezcan al conjunto de vuelos posibles.

\newpage
Por lo tanto nuestro algoritmo final quedaria de la siguiente manera:

Definimos Color como un enum $[$BLANCO,ROJO,VERDER$]$

Definimos un Aeropuerto como un tupla $\langle$ ciudad$:$Ciudad,vuelosQueSalen$:
$Conj(Vuelo),

vuelosQueLlegan$:$Conj(Vuelo),id$:$Nat,color$:$Color $\rangle$ 



\begin{algorithm}[H]
\begin{algorithmic}[1]
\STATE Aeropuerto[] aeropuertos = construirArrayDeAeropuertos(vuelos,inicio,final)

$//$Esta funcion va a asignarle un id a cada una de las ciudades y luego construir un array donde en la posicion i, se encuentra la ciudad con id $=$ 1

\STATE Sec$\langle$Vuelo$\rangle$ $itinerario$ $=$ $[]$

$//$ Esta sesgada la funcion con T $=$ -2 ya que vamos a preguntar si existeVuelo a partir de T $=$ 0	


Esta funcion tambien me va a colorear de verde los vuelos que encuentre que lleguen a destino

En la posicion 0 se encuentra el aerpuerto de la ciudad inicial, y en la posicio 1, el de la ciudad final

\IF{(existeVuelo(aeropuertos, aeropuertos[0],aeropuertos[1],-2))}
	\STATE Vuelo min = vueloMinimo(aeropuerto$[1]$.vuelosQueLlegan())
\ENDIF
\STATE $itinerario$.agregar(min,0)
\WHILE {(min.inicio != inicio) }
	\STATE Vuelo min $=$ vueloMinimo(min.inicio.vuelosQueLlegan())
	\STATE $itinerario$.agregar(min,0)
\ENDWHILE
\RETURN $itinerario$
\caption{Sec$\langle$Vuelo$\rangle$ itinerario(Conj(Vuelo) vuelos, Ciudad inicio, Ciudad final)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\STATE Conj(Ciudad) ciudades = null
\STATE ciudades.agregar(inicio)
\STATE ciudades.agregar(final)
\FOR {(Vuelo vuelo: Vuelos)}	
	\STATE ciudades.agregar(vuelo.origen)
	\STATE ciudades.agregar(vuelo.destino)
\ENDFOR
\STATE Aeropuerto[] aeropuertos = new Aeropuerto[ciudades.size];
\STATE Mapa$\langle$Ciudad, Nat$\rangle$ ids $=$ $\emptyset$
\STATE ids.agregar(inicio,0)
\STATE ids.agregar(final,1)
\STATE aeropuertos[0] = new Aeropuerto (inicio,$\emptyset$,$\emptyset$,0)
\STATE aeropuertos[1] = new Aeropuerto (final,$\emptyset$,$\emptyset$,1)
\STATE ciudades.remover(inicio)
\STATE ciudades.remover(final)
\STATE Nat i = 2
\FOR {(Ciudad ciudad: ciudades)}	
	\STATE aeropuertos[i] = new Aeropuerto (ciudad,$\emptyset$,$\emptyset$,i)
	\STATE ids.agregar(ciudad,i++)
\ENDFOR
\STATE i $=$ 1
\FOR {(Vuelo vuelo: Vuelos)}	
	\STATE vuelo.id = i	
	\STATE vuelo.color = BLANCO	
	\STATE int id = ids.obtener(vuelo.origen)
	\STATE ciudades.obtener(id).vuelosQueSalen().agregar(vuelo)
	\STATE int id = ids.obtener(vuelo.destino)
	\STATE ciudades.obtener(id).vuelosQueLlegan().agregar(vuelo)
\ENDFOR
\RETURN ciudades
\caption{Aeropuerto[] construirArrayDeAeropuertos(Conj(Vuelo) vuelos, Ciudad inicio, Ciudad final)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}

Esta funcion implementada sobre un trie o sobre un hashmap, para el diccionario de ids me daria una complejidad final al algoritmo cercana a O(n) en n numero de vuelos. Los nombres de la ciudad tienden a ser Strings de bajo costo de procesamiento en un trie, y en un hashmap la cantidad total de ciudades con aeropuertos en el mundo, es bastante baja por lo tanto se podr\'ia implementar de forma eficiente.
Nuestra implementaci\'on es en un treeset.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\IF {(inicio $==$ destino)}	
		\RETURN TRUE
\ENDIF
\STATE boolean llego $=$ false;
\FOR{(Vuelo v $:$ inicio$.$vuelosQueSalen)}	    
    \IF {(v.despegue $\geq$ t+2)}	
		\IF{(v.color $==$ VERDE)}
			\STATE llego = TRUE
        \ENDIF
        \IF{(v.color $==$ BLANCO)}     				        	
        		\IF {(existeVuelo(aeropuertos,v.destino,final,v.aterrizaje)}
				\STATE llego = true;
				\STATE v.color = VERDE;
			\ELSE
				\STATE v.color = ROJO;								
	    		\ENDIF    			
		\ENDIF		    
    \ENDIF
\ENDFOR
\RETURN $llego$
\caption{boolean existeVuelo(Aeropuerto[] aeropuertos, Aeropuerto inicio, Aeropuerto final, int t)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\begin{algorithmic}[1]
\STATE Vuelo min = null
\FOR{(Vuelo v: vuelos)}
	\STATE min $=$ (min$==$null $\vee$ v.aterrizaje $\leq$ min.aterrizaje) $\wedge$ v.color $==$ VERDE
\ENDFOR
\RETURN min
\caption{Vuelo vueloMinimo(Conj(Vuelo) vuelos)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}

//A PARTIR DE ACA NO SE QUE VOY A PONER Y QUE NO


Primero notamos que para encontrar el mejor itinerario de movimientos de un turista, yendo de ciudad a ciudad en aviones, iba a ser necesario recorrer los vuelos que sean posibles desde la ciudad donde estabamos parados y ver a que otros vuelos nos llevaban. 

Notamos que dado un instante T, el flujo de vuelos que pod\'iamos tomarnos desde una ciudad dependia siempre de la ciudad inicial, y del momento en el que nos encontremos en esa ciudad, y nos iba a interesar solo los que finalizaran en la ciudad final con menor instante de aterrizaje.

Luego para que nuestra soluc\'on tuviera el menor instante T de aterrizaje en $destino$, vamos a definir al m\'inimo vuelo posible en nuestra ciudad final tal que:

m\'inimoFinal $\equiv$ v $\Leftrightarrow$ 


Por lo tanto se podria visualizar el flujo de aviones de ciudad en ciudad como una grafo direccional donde los vertices son las ciudades, y existen aristas por cada uno de los vuelos. 

Sin ninguna restricci\'on a partir de esto, no podr\'iamos introducir el concepto de horario de vuelo.
Estas aristas no ibamos a poder recorrerlas de cualquier forma, ya que un vuelo solo puedo tomarmelo en determinados horarios de arribo a una ciudad. 

Por lo tanto ibamos a necesitar recorrerlas asociadas a un T:Nat que seria el tiempo desde que salimos desde el origen hasta llegar a la ciudad actual.

Viendo esta estructura podriamos recorrer con un BFS modificado, los caminos que lleven de a hasta b, agregandole una variable temporal a ese BFS, para el descubrimiento de aristas realizarlo solo si el vuelo asociado despegaba despu\'es del instante T de llegada.

A ese T, que seria el tiempo de entrada a una ciudad habria que agregarle 2hs, que son las que se necesitan para los tr\'amites un usuario del itinerario. Tambi\'en notamos que podriamos simplemente cargar el despegue de los vuelos como 2 hs antes ya que llegar a una ciudad y esperar 2 hs para el despegue, es lo mismo que decir que el despegue es 2 horas antes.

Con esta estructura y con un BFS modificado para considerar un tiempo T, podr\'iamos hallar todos los caminos que vayan desde a hasta b. 

El problema que notamos es que esta funci\'on a priori, era bastante ineficiente. ya que si llegabamos a una ciudad dos veces con el mismo instante t, debiamos calcular dos veces si un camino de vuelos nos llebaba a una soluci\'on o no.

Para optimizar este mecanimos, optamos por marcar cuando sean posibles y cuando no llega a la ciudad final dado que nos tomamos un cierto vuelo. Para marcarlo utilzamos, un flag de coloreo para aristas.

Con este coloreo no solo logramos que nuestro algoritmo recorra exactamente una vez cada arista, sino que no reorra aristas que nunca se puede tomar.

Tomamos la idea de coloreo del recorrido de un BFS, del libro Introduction to algorithm, donde lo usa para marcar nodos totalmente descubiertos, nodos parcialmente descubiertos y nodos sin descubrir.

En nuestra implementaci\'on vamos a colorear aristas, ya que lo que queremos marcar son los vuelos que nos lleven desde a hasta b.

Luego simplemente podemos ir al nodo que le corresponde a la ciudad b, tomarnos el vuelo que tenga aterrizaje m\'inimo, es decir el que primero llegue a la ciudad final b y recorrer cualquier camino marcado como posible hasta a.

Notamos entonces que para todo vuelo v, yo puedo definir una subsoluci\'on optima dado un instante T tal que me diga el mejor camino de vuelos a partir de tomarme v.
Por lo tanto, nuestra solucion seria el mejor camino de vuelos que yo puedo tomarme a partir de tomarme cualquier vuelo que salga de la ciudad inicial con T = 0, con esa idea creamos la siguiente funcion recursiva.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\FOR {(Vuelo v: m.obtener(inicio).vuelosDeSalida) }
	\IF {(v.destino $==$ destino)}	
		\STATE return TRUE
	\ENDIF
    \IF {(v.despegue $\geq$ t)}	
        \RETURN existeVuelo(m,v.destino,final,v.aterrizaje)
    \ENDIF
\ENDFOR
\RETURN $FALSE$
\caption{boolean existeVuelo(Mapa$<$Ciudad,Vuelo$>$) m, Ciudad inicio, Ciudad final, int t)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}

Donde m es el mapa de $<$Ciudad,Conj(Vuelo)$>$ tal que dada un conjunto c de vuelos, las claves de m son las Ciudades(c) y en el valor de cada clave, obtengo los vuelos que salen y llegan de esa ciudad. Luego veremos que costruir este mapa nos va a agregar un costo a la complejidad final del algoritmo.  

Lo que consigo con este algoritmo es un boolean que me indica si llego a la ciudad final desde una ciudad inicial con un tiempo asociado. Entonces lo que nos interesaria saber a nosotros es si existeVuelo(m,a,b,0) $\equiv$ TRUE. 

Como vemos podemos relacionar este algoritmo con la t\'ecnica recursiva de BFS.

Como vemos esta funci\'on recursiva tiene un costo alto de complejidad ya que si por ejemplo llegamos desde dos caminos distintos a la misma ciudad y luego tomamos el mismo vuelo para salir de ella, no sabriamos a priori que ese camino ya se calculo en la primera iteraci\'on. He aqu\'i que agregamos el concepto de Colores a los caminos.

Vamos a marcar a todos los vuelos en color Blanco al principio del algoritmo, para poder identificar los vuelos que todavia no nos pudimos tomar.

Vamos a marcar de color verde los vuelos a los que por algun camino llegamos a la ciudad destino, por un camino de vuelos o en su defecto llegamos a un camino verde.

Y finalmente vamos a marcar de color rojo a todo vuelo v que dado que nos lo tomamos no llegamos a ning\'un camino verde ni al destino.

Para ello vamos a modificar levemente el algoritmo anterior de recorrido de nuestro sistema. Recordemos, los vuelos inician en color BLANCO.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\IF {(v.destino $==$ destino)}	
		\RETURN TRUE
\ENDIF
\STATE boolean llego = false;
\FOR {(Vuelo v: m.obtener(inicio).vuelosDeSalida) }	    
    \IF {(v.despegue $\geq$ t)}	
		\IF{(v.color $==$ VERDE)}
			\STATE llego = TRUE
        \ENDIF
        \IF{(v.color $==$ BLANCO)}     				        	
        		\IF {(existeVuelo(m,v.destino,final,v.aterrizaje)}
				\STATE llego = true;
				\STATE v.color = VERDE;
			\ELSE
				\STATE v.color = ROJO;								
	    		\ENDIF    			
		\ENDIF		    
    \ENDIF
\ENDFOR
\RETURN $llego$
\caption{boolean existeVuelo(Mapa$<$Ciudad,Vuelo$>$) m, Ciudad inicio, Ciudad final, int t)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}

Con este algoritmo cuando terminemos de recorrer el sistema de vuelos, vamos a tener que agarrar el camino Verde, que nos lleve al primer vuelo que aterrice en la ciudad final y este marcado del mismo color.

Para eso lo que haremos ser\'a obtener recursivamente las ciudades desde nuestra ciudad final, tomandome exactamente el primer vuelo que aterrice y sea de color verde.

Ahora nuestra variable T, va a ser el horario de despegue de cada vuelo que haya tomado. 

Es decir, si el primer vuelo que llega a mi ciudad final (o sea el de menor horario de aterrizaje) y tenga color verde tiene un horario de despegue a las 14hs y sale de la ciudad $c$, entonces voy a buscar los vuelos que esten marcados de verde y lleguen a c en horario menor o igual a 14hs. Recordemos aca entra en juego, lo de alargar el horario de aterrizaje 2 horas para cada vuelo.
Como mi vuelo pertenecia a un camino verde, existe al menos un vuelo que sale de $c$ y aterriza antes de las 14hs.

Luego la sucesi\'on de vuelos obtenida de esta manera desde la ciudad final, comenzando con T = $\infty$ es una soluci\'on a nuestro problema ya que va desde a hasta b, y el \'ultimo vuelo de esa sucesi\'on es el de menor horario de aterrizaje en b, de los vuelos que llegan desde a hasta b por un camino verde.

\subsection{Demostración}

\subsection{Análisis de complejidad}

\subsection{Tests de complejidad}
