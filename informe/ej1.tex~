\section{Problema 1: Plan de vuelo}

\subsection{Presentación del problema}

Se quiere crear un sitio web para reservas de pasajes de avi\'on. El sitio debe tener un sistema de b\'usqueda de itinerarios de vuelo. Un itinerario de vuelo, es una sucesi\'on de vuelos los cuales logran llevarte hacia un destino. Dado una ciudad de salida, y una ciudad de llegada, se busca crear un itinirario de vuelos que me lleve desde la ciudad de salida hasta la de llegada.

Dentro de este itinerario, cada vuelo tiene un horario de despegue y uno de aterrizaje. 

Para poder ser un itinerario valido, la ciudad de destino de un vuelo, tiene que ser la ciudad de llegada del pr\'oximo o directamente el destino donde queriamos llegar, y en particular cada vez que llego a una ciudad debo esperar al menos dos horas desde el aterrizaje, para poder tomarme un vuelo, lo cual resulta l\'ogico dado que una persona puede necesitar al menos ese tiempo para tr\'amites de aeropuerto.

Es por eso que se nos pide el mejor itinerario, teniendo al menos dos horas entre cada vuelo, donde mejor itinerario es el que primero llega a la ciudad destino.

Adem\'as se nos pide que la resoluci\'on de este problema se implemente en un complejidad no peor a O($N^{2}$) donde N es la cantidad de vuelos totales que existen en todo el sistema (formen parte del itinerario o no).

\newpage
\subsubsection{Formalmente}


Sea Ciudad un renombre de String.

Sea Vuelo una tupla $<$despegue:Nat, aterrizaje:Nat, origen:Ciudad, destino:Ciudad$>$

Dado $vuelos$:Conj(Vuelo):

Llamemos a $ciudadades$:Conj(Ciudad) al conjunto tal que:

($\forall$ $c$:Ciudad, $c$ $\in$ $ciudades$)  $\Leftrightarrow$ ($\exists$ $v$:Vuelo$/$ $v$ $\in$ $vuelos$ $\wedge$ ($v$.origen $\equiv$ $c$ $\vee$ $v$.destino $\equiv$ $c$))

Dadas $a,b$:Ciudad, $a,b \in ciudades$. 

Sean los enunciados:

esItinerarioValido(Sec$<$Vuelo$>$ $S$, Ciudad a, Ciudad b) $\equiv$
 
($S_{0}$.origen $\equiv a \wedge S_{S.tamanio-1}$.destino$ \equiv b) \wedge$ 

($\forall$ $i$:Nat, 0 $<$ i $<S.tamanio$)($S_{i}$.destino $\equiv$ $S_{i+1}$.origen 

$\wedge$ $S_{i}$.aterrizaje + 2 $\leq$ $S_{i+1}$.despegue))


Sec$<$Vuelo$>$ s $\subseteq$ Conj(Vuelo) c $\equiv$ 

($\forall i:$Nat, 0 $\leq i \geq$ s )($s_{i}$ $\in $ c) 
 

Se nos pide encontrar $S$:Sec$<$Vuelo$>$ tal que 

esItinerarioValido($S$,a,b) $\wedge$ ($S \subseteq$ vuelos) $\wedge$ 

$(\forall$ $S'$:Sec$<$Vuelo$>$ $/$ (esItinerarioValido($S'$,a,b)) $\wedge$ ($S' \subseteq$ vuelos) $\implies$  

$S_{S.tamanio-1}$.aterrizaje$) \leq S'_{S'.tamanio-1}$.aterrizaje))


\newpage
\subsection{Resolución}

Habiendo caracterizado la soluci\'on a nuestro problema en leguaje formal, vamos a tratar de encontrar una implementaci\'on para un algoritmo que devuelva una instancia de esa soluci\'on.

Primero notamos que para encontrar el mejor itinerario de movimientos de un turista, yendo de ciudad a ciudad en aviones, iba a ser necesario en particular recorrer al menos una vez todos los vuelos existentes y ver a que otros vuelos nos llevaban. 

Notamos que dado un instante T, El flujo de vuelos que pod\'iamos tomarnos desde una ciudad dependia siempre de la ciudad inicial, y del momento en el que nos encontremos en esa ciudad, y nos iba a interesar solo los que finalizaran en la ciudad final.

Por lo tanto se podria visualizar el flujo de aviones de ciudad en ciudad como una grafo direccional donde los vertices son las ciudades, y existen aristas por cada uno de los vuelos. 

Sin ninguna restricci\'on a partir de esto, no podr\'iamos introducir el concepto de horario de vuelo.
Estas aristas no ibamos a poder recorrerlas de cualquier forma, ya que un vuelo solo puedo tomarmelo en determinados horarios de arribo a una ciudad. 

Por lo tanto ibamos a necesitar recorrerlas asociadas a un T:Nat que seria el tiempo desde que salimos desde el origen hasta llegar a la ciudad actual.

Viendo esta estructura podriamos recorrer con un BFS modificado, los caminos que lleven de a hasta b, agregandole una variable temporal a ese BFS, para el descubrimiento de aristas realizarlo solo si el vuelo asociado despegaba despu\'es del instante T de llegada.

A ese T, que seria el tiempo de entrada a una ciudad habria que agregarle 2hs, que son las que se necesitan para los tr\'amites un usuario del itinerario. Tambi\'en notamos que podriamos simplemente cargar el despegue de los vuelos como 2 hs antes ya que llegar a una ciudad y esperar 2 hs para el despegue, es lo mismo que decir que el despegue es 2 horas antes.

Con esta estructura y con un BFS modificado para considerar un tiempo T, podr\'iamos hallar todos los caminos que vayan desde a hasta b. 

El problema que notamos es que esta funci\'on a priori, era bastante ineficiente. ya que si llegabamos a una ciudad dos veces con el mismo instante t, debiamos calcular dos veces si un camino de vuelos nos llebaba a una soluci\'on o no.

Para optimizar este mecanimos, optamos por marcar cuando sean posibles y cuando no llega a la ciudad final dado que nos tomamos un cierto vuelo. Para marcarlo utilzamos, un flag de coloreo para aristas.

Con este coloreo no solo logramos que nuestro algoritmo recorra exactamente una vez cada arista, sino que no reorra aristas que nunca se puede tomar.

Tomamos la idea de coloreo del recorrido de un BFS, del libro Introduction to algorithm, donde lo usa para marcar nodos totalmente descubiertos, nodos parcialmente descubiertos y nodos sin descubrir.

En nuestra implementaci\'on vamos a colorear aristas, ya que lo que queremos marcar son los vuelos que nos lleven desde a hasta b.

Luego simplemente podemos ir al nodo que le corresponde a la ciudad b, tomarnos el vuelo que tenga aterrizaje m\'inimo, es decir el que primero llegue a la ciudad final b y recorrer cualquier camino marcado como posible hasta a.

Notamos entonces que para todo vuelo v, yo puedo definir una subsoluci\'on optima dado un instante T tal que me diga el mejor camino de vuelos a partir de tomarme v.
Por lo tanto, nuestra solucion seria el mejor camino de vuelos que yo puedo tomarme a partir de tomarme cualquier vuelo que salga de la ciudad inicial con T = 0, con esa idea creamos la siguiente funcion recursiva.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\FOR {(Vuelo v: m.obtener(inicio).vuelosDeSalida) }
	\IF {(v.destino $==$ destino)}	
		\STATE return TRUE
	\ENDIF
    \IF {(v.despegue $\geq$ t)}	
        \RETURN existeVuelo(m,v.destino,final,v.aterrizaje)
    \ENDIF
\ENDFOR
\RETURN $FALSE$
\caption{boolean existeVuelo(Mapa$<$Ciudad,Vuelo$>$) m, Ciudad inicio, Ciudad final, int t)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}

Donde m es el mapa de $<$Ciudad,Conj(Vuelo)$>$ tal que dada un conjunto c de vuelos, las claves de m son las Ciudades(c) y en el valor de cada clave, obtengo los vuelos que salen y llegan de esa ciudad. Luego veremos que costruir este mapa nos va a agregar un costo a la complejidad final del algoritmo.  

Lo que consigo con este algoritmo es un boolean que me indica si llego a la ciudad final desde una ciudad inicial con un tiempo asociado. Entonces lo que nos interesaria saber a nosotros es si existeVuelo(m,a,b,0) $\equiv$ TRUE. 

Como vemos podemos relacionar este algoritmo con la t\'ecnica recursiva de BFS.

Como vemos esta funci\'on recursiva tiene un costo alto de complejidad ya que si por ejemplo llegamos desde dos caminos distintos a la misma ciudad y luego tomamos el mismo vuelo para salir de ella, no sabriamos a priori que ese camino ya se calculo en la primera iteraci\'on. He aqu\'i que agregamos el concepto de Colores a los caminos.

Vamos a marcar a todos los vuelos en color Blanco al principio del algoritmo, para poder identificar los vuelos que todavia no nos pudimos tomar.

Vamos a marcar de color verde los vuelos a los que por algun camino llegamos a la ciudad destino, por un camino de vuelos o en su defecto llegamos a un camino verde.

Y finalmente vamos a marcar de color rojo a todo vuelo v que dado que nos lo tomamos no llegamos a ning\'un camino verde ni al destino.

Para ello vamos a modificar levemente el algoritmo anterior de recorrido de nuestro sistema. Recordemos, los vuelos inician en color BLANCO.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\IF {(v.destino $==$ destino)}	
		\RETURN TRUE
\ENDIF
\STATE boolean llego = false;
\FOR {(Vuelo v: m.obtener(inicio).vuelosDeSalida) }	    
    \IF {(v.despegue $\geq$ t)}	
		\IF{(v.color $==$ VERDE)}
			\STATE llego = TRUE
        \ENDIF
        \IF{(v.color $==$ BLANCO)}     				        	
        		\IF {(existeVuelo(m,v.destino,final,v.aterrizaje)}
				\STATE llego = true;
				\STATE v.color = VERDE;
			\ELSE
				\STATE v.color = ROJO;								
	    		\ENDIF    			
		\ENDIF		    
    \ENDIF
\ENDFOR
\RETURN $llego$
\caption{boolean existeVuelo(Mapa$<$Ciudad,Vuelo$>$) m, Ciudad inicio, Ciudad final, int t)}% $\rightarrow$ int proximo}
\end{algorithmic}
\end{algorithm}

Con este algoritmo cuando terminemos de recorrer el sistema de vuelos, vamos a tener que agarrar el camino Verde, que nos lleve al primer vuelo que aterrice en la ciudad final y este marcado del mismo color.

Para eso lo que haremos sera obtener recursivamente las ciudades desde nuestra ciudad final, tomandome exactamente el primer vuelo que aterrice en mi ciudad final.

Ahora nuestra variable T, va a ser el horario de despegue de cada vuelo que haya tomado. 

Es decir, si el primer vuelo que llega a mi ciudad final (o sea el de menor horario de aterrizaje) y tenga color verde tiene un horario de despegue a las 14hs y sale de la ciudad $c$, entonces voy a buscar los vuelos que esten marcados de verde y lleguen a c en horario menor o igual a 14hs. Recordemos aca entra en juego, lo de alargar el horario de aterrizaje, 2 horas para cada vuelo.
Como mi vuelo pertenecia a un camino verde, existe al menos un vuelo que sale de $c$ y aterriza antes de las 14hs.

Luego la sucesi\'on de vuelos obtenida de esta manera desde la ciudad final, comenzando con T = $\infty$ es una soluci\'on a nuestro problema ya que va desde a hasta b, y el ultimo vuelo de esa sucesi\'on es el de menor horario de aterrizaje en b, de los vuelos que llegan desde a hasta b por un camino verde.

\subsection{Demostración}

\subsection{Análisis de complejidad}

\subsection{Tests de complejidad}
